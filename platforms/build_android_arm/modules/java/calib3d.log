ok: CLASS ..Calib3d : 


===== Header: /home/aydinkim/clab/opencv-3.0.0-android/modules/calib3d/include/opencv2/calib3d/calib3d_c.h =====
Namespaces: set([''])

--- Incoming ---
[u'const CV_ITERATIVE', u'0', [], []]
ok: CONST CV_ITERATIVE=0

--- Incoming ---
[u'const CV_EPNP', u'1', [], []]
ok: CONST CV_EPNP=1

--- Incoming ---
[u'const CV_P3P', u'2', [], []]
ok: CONST CV_P3P=2

--- Incoming ---
[u'const CV_DLS', u'3', [], []]
ok: CONST CV_DLS=3

--- Incoming ---
[u'const CvLevMarq.DONE', u'0', [], []]
class not found: CONST DONE=0

--- Incoming ---
[u'const CvLevMarq.STARTED', u'1', [], []]
class not found: CONST STARTED=1

--- Incoming ---
[u'const CvLevMarq.CALC_J', u'2', [], []]
class not found: CONST CALC_J=2

--- Incoming ---
[u'const CvLevMarq.CHECK_ERR', u'3', [], []]
class not found: CONST CHECK_ERR=3


===== Header: /home/aydinkim/clab/opencv-3.0.0-android/modules/calib3d/include/opencv2/calib3d.hpp =====
Namespaces: set(['', u'cv.fisheye', u'cv'])

--- Incoming ---
[u'const cv.LMEDS', u'4', [], []]
ok: CONST LMEDS=4

--- Incoming ---
[u'const cv.RANSAC', u'8', [], []]
ok: CONST RANSAC=8

--- Incoming ---
[u'const cv.RHO', u'16', [], []]
ok: CONST RHO=16

--- Incoming ---
[u'const cv.SOLVEPNP_ITERATIVE', u'0', [], []]
ok: CONST SOLVEPNP_ITERATIVE=0

--- Incoming ---
[u'const cv.SOLVEPNP_EPNP', u'1', [], []]
ok: CONST SOLVEPNP_EPNP=1

--- Incoming ---
[u'const cv.SOLVEPNP_P3P', u'2', [], []]
ok: CONST SOLVEPNP_P3P=2

--- Incoming ---
[u'const cv.SOLVEPNP_DLS', u'3', [], []]
ok: CONST SOLVEPNP_DLS=3

--- Incoming ---
[u'const cv.SOLVEPNP_UPNP', u'4', [], []]
ok: CONST SOLVEPNP_UPNP=4

--- Incoming ---
[u'const cv.CALIB_CB_ADAPTIVE_THRESH', u'1', [], []]
ok: CONST CALIB_CB_ADAPTIVE_THRESH=1

--- Incoming ---
[u'const cv.CALIB_CB_NORMALIZE_IMAGE', u'2', [], []]
ok: CONST CALIB_CB_NORMALIZE_IMAGE=2

--- Incoming ---
[u'const cv.CALIB_CB_FILTER_QUADS', u'4', [], []]
ok: CONST CALIB_CB_FILTER_QUADS=4

--- Incoming ---
[u'const cv.CALIB_CB_FAST_CHECK', u'8', [], []]
ok: CONST CALIB_CB_FAST_CHECK=8

--- Incoming ---
[u'const cv.CALIB_CB_SYMMETRIC_GRID', u'1', [], []]
ok: CONST CALIB_CB_SYMMETRIC_GRID=1

--- Incoming ---
[u'const cv.CALIB_CB_ASYMMETRIC_GRID', u'2', [], []]
ok: CONST CALIB_CB_ASYMMETRIC_GRID=2

--- Incoming ---
[u'const cv.CALIB_CB_CLUSTERING', u'4', [], []]
ok: CONST CALIB_CB_CLUSTERING=4

--- Incoming ---
[u'const cv.CALIB_USE_INTRINSIC_GUESS', u'0x00001', [], []]
manual: CONST CALIB_USE_INTRINSIC_GUESS=0x00001

--- Incoming ---
[u'const cv.CALIB_FIX_ASPECT_RATIO', u'0x00002', [], []]
ok: CONST CALIB_FIX_ASPECT_RATIO=0x00002

--- Incoming ---
[u'const cv.CALIB_FIX_PRINCIPAL_POINT', u'0x00004', [], []]
ok: CONST CALIB_FIX_PRINCIPAL_POINT=0x00004

--- Incoming ---
[u'const cv.CALIB_ZERO_TANGENT_DIST', u'0x00008', [], []]
ok: CONST CALIB_ZERO_TANGENT_DIST=0x00008

--- Incoming ---
[u'const cv.CALIB_FIX_FOCAL_LENGTH', u'0x00010', [], []]
ok: CONST CALIB_FIX_FOCAL_LENGTH=0x00010

--- Incoming ---
[u'const cv.CALIB_FIX_K1', u'0x00020', [], []]
manual: CONST CALIB_FIX_K1=0x00020

--- Incoming ---
[u'const cv.CALIB_FIX_K2', u'0x00040', [], []]
manual: CONST CALIB_FIX_K2=0x00040

--- Incoming ---
[u'const cv.CALIB_FIX_K3', u'0x00080', [], []]
manual: CONST CALIB_FIX_K3=0x00080

--- Incoming ---
[u'const cv.CALIB_FIX_K4', u'0x00800', [], []]
manual: CONST CALIB_FIX_K4=0x00800

--- Incoming ---
[u'const cv.CALIB_FIX_K5', u'0x01000', [], []]
ok: CONST CALIB_FIX_K5=0x01000

--- Incoming ---
[u'const cv.CALIB_FIX_K6', u'0x02000', [], []]
ok: CONST CALIB_FIX_K6=0x02000

--- Incoming ---
[u'const cv.CALIB_RATIONAL_MODEL', u'0x04000', [], []]
ok: CONST CALIB_RATIONAL_MODEL=0x04000

--- Incoming ---
[u'const cv.CALIB_THIN_PRISM_MODEL', u'0x08000', [], []]
ok: CONST CALIB_THIN_PRISM_MODEL=0x08000

--- Incoming ---
[u'const cv.CALIB_FIX_S1_S2_S3_S4', u'0x10000', [], []]
ok: CONST CALIB_FIX_S1_S2_S3_S4=0x10000

--- Incoming ---
[u'const cv.CALIB_FIX_INTRINSIC', u'0x00100', [], []]
manual: CONST CALIB_FIX_INTRINSIC=0x00100

--- Incoming ---
[u'const cv.CALIB_SAME_FOCAL_LENGTH', u'0x00200', [], []]
ok: CONST CALIB_SAME_FOCAL_LENGTH=0x00200

--- Incoming ---
[u'const cv.CALIB_ZERO_DISPARITY', u'0x00400', [], []]
ok: CONST CALIB_ZERO_DISPARITY=0x00400

--- Incoming ---
[u'const cv.FM_7POINT', u'1', [], []]
ok: CONST FM_7POINT=1

--- Incoming ---
[u'const cv.FM_8POINT', u'2', [], []]
ok: CONST FM_8POINT=2

--- Incoming ---
[u'const cv.FM_LMEDS', u'4', [], []]
ok: CONST FM_LMEDS=4

--- Incoming ---
[u'const cv.FM_RANSAC', u'8', [], []]
ok: CONST FM_RANSAC=8

--- Incoming ---
[   u'cv.Rodrigues',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'jacobian', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv..Rodrigues [ARG Mat src=, ARG Mat dst=, ARG Mat jacobian=Mat()]>

--- Incoming ---
[   u'cv.findHomography',
    u'Mat',
    [],
    [   ['Mat', u'srcPoints', '', []],
        ['Mat', u'dstPoints', '', []],
        [u'int', u'method', u'0', []],
        [u'double', u'ransacReprojThreshold', u'3', []],
        ['Mat', u'mask', u'Mat()', ['/O']],
        [u'int', u'maxIters', u'2000', []],
        [u'double', u'confidence', u'0.995', []]],
    u'Mat']
ok: FUNC <Mat cv..findHomography [ARG vector_Point2f srcPoints=, ARG vector_Point2f dstPoints=, ARG int method=0, ARG double ransacReprojThreshold=3, ARG Mat mask=Mat(), ARG int maxIters=2000, ARG double confidence=0.995]>

--- Incoming ---
[   u'cv.RQDecomp3x3',
    u'Vec3d',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'mtxR', '', ['/O']],
        ['Mat', u'mtxQ', '', ['/O']],
        ['Mat', u'Qx', u'Mat()', ['/O']],
        ['Mat', u'Qy', u'Mat()', ['/O']],
        ['Mat', u'Qz', u'Mat()', ['/O']]],
    u'Vec3d']
ok: FUNC <Vec3d cv..RQDecomp3x3 [ARG Mat src=, ARG Mat mtxR=, ARG Mat mtxQ=, ARG Mat Qx=Mat(), ARG Mat Qy=Mat(), ARG Mat Qz=Mat()]>

--- Incoming ---
[   u'cv.decomposeProjectionMatrix',
    u'void',
    [],
    [   ['Mat', u'projMatrix', '', []],
        ['Mat', u'cameraMatrix', '', ['/O']],
        ['Mat', u'rotMatrix', '', ['/O']],
        ['Mat', u'transVect', '', ['/O']],
        ['Mat', u'rotMatrixX', u'Mat()', ['/O']],
        ['Mat', u'rotMatrixY', u'Mat()', ['/O']],
        ['Mat', u'rotMatrixZ', u'Mat()', ['/O']],
        ['Mat', u'eulerAngles', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv..decomposeProjectionMatrix [ARG Mat projMatrix=, ARG Mat cameraMatrix=, ARG Mat rotMatrix=, ARG Mat transVect=, ARG Mat rotMatrixX=Mat(), ARG Mat rotMatrixY=Mat(), ARG Mat rotMatrixZ=Mat(), ARG Mat eulerAngles=Mat()]>

--- Incoming ---
[   u'cv.matMulDeriv',
    u'void',
    [],
    [   ['Mat', u'A', '', []],
        ['Mat', u'B', '', []],
        ['Mat', u'dABdA', '', ['/O']],
        ['Mat', u'dABdB', '', ['/O']]],
    u'void']
ok: FUNC <void cv..matMulDeriv [ARG Mat A=, ARG Mat B=, ARG Mat dABdA=, ARG Mat dABdB=]>

--- Incoming ---
[   u'cv.composeRT',
    u'void',
    [],
    [   ['Mat', u'rvec1', '', []],
        ['Mat', u'tvec1', '', []],
        ['Mat', u'rvec2', '', []],
        ['Mat', u'tvec2', '', []],
        ['Mat', u'rvec3', '', ['/O']],
        ['Mat', u'tvec3', '', ['/O']],
        ['Mat', u'dr3dr1', u'Mat()', ['/O']],
        ['Mat', u'dr3dt1', u'Mat()', ['/O']],
        ['Mat', u'dr3dr2', u'Mat()', ['/O']],
        ['Mat', u'dr3dt2', u'Mat()', ['/O']],
        ['Mat', u'dt3dr1', u'Mat()', ['/O']],
        ['Mat', u'dt3dt1', u'Mat()', ['/O']],
        ['Mat', u'dt3dr2', u'Mat()', ['/O']],
        ['Mat', u'dt3dt2', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv..composeRT [ARG Mat rvec1=, ARG Mat tvec1=, ARG Mat rvec2=, ARG Mat tvec2=, ARG Mat rvec3=, ARG Mat tvec3=, ARG Mat dr3dr1=Mat(), ARG Mat dr3dt1=Mat(), ARG Mat dr3dr2=Mat(), ARG Mat dr3dt2=Mat(), ARG Mat dt3dr1=Mat(), ARG Mat dt3dt1=Mat(), ARG Mat dt3dr2=Mat(), ARG Mat dt3dt2=Mat()]>

--- Incoming ---
[   u'cv.projectPoints',
    u'void',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'rvec', '', []],
        ['Mat', u'tvec', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'imagePoints', '', ['/O']],
        ['Mat', u'jacobian', u'Mat()', ['/O']],
        [u'double', u'aspectRatio', u'0', []]],
    u'void']
ok: FUNC <void cv..projectPoints [ARG vector_Point3f objectPoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG vector_Point2f imagePoints=, ARG Mat jacobian=Mat(), ARG double aspectRatio=0]>

--- Incoming ---
[   u'cv.solvePnP',
    u'bool',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/O']],
        ['Mat', u'tvec', '', ['/O']],
        [u'bool', u'useExtrinsicGuess', u'false', []],
        [u'int', u'flags', u'SOLVEPNP_ITERATIVE', []]],
    u'bool']
ok: FUNC <bool cv..solvePnP [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int flags=SOLVEPNP_ITERATIVE]>

--- Incoming ---
[   u'cv.solvePnPRansac',
    u'bool',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/O']],
        ['Mat', u'tvec', '', ['/O']],
        [u'bool', u'useExtrinsicGuess', u'false', []],
        [u'int', u'iterationsCount', u'100', []],
        [u'float', u'reprojectionError', u'8.0', []],
        [u'double', u'confidence', u'0.99', []],
        ['Mat', u'inliers', u'Mat()', ['/O']],
        [u'int', u'flags', u'SOLVEPNP_ITERATIVE', []]],
    u'bool']
ok: FUNC <bool cv..solvePnPRansac [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int iterationsCount=100, ARG float reprojectionError=8.0, ARG double confidence=0.99, ARG Mat inliers=Mat(), ARG int flags=SOLVEPNP_ITERATIVE]>

--- Incoming ---
[   u'cv.initCameraMatrix2D',
    u'Mat',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'double', u'aspectRatio', u'1.0', []]],
    u'Mat']
ok: FUNC <Mat cv..initCameraMatrix2D [ARG vector_vector_Point3f objectPoints=, ARG vector_vector_Point2f imagePoints=, ARG Size imageSize=, ARG double aspectRatio=1.0]>

--- Incoming ---
[   u'cv.findChessboardCorners',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'corners', '', ['/O']],
        [   u'int',
            u'flags',
            u'CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE',
            []]],
    u'bool']
ok: FUNC <bool cv..findChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE]>

--- Incoming ---
[   u'cv.drawChessboardCorners',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'corners', '', []],
        [u'bool', u'patternWasFound', u'', []]],
    u'void']
ok: FUNC <void cv..drawChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG bool patternWasFound=]>

--- Incoming ---
[   u'cv.findCirclesGrid',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'centers', '', ['/O']],
        [u'int', u'flags', u'CALIB_CB_SYMMETRIC_GRID', []],
        [   u'Ptr_FeatureDetector',
            u'blobDetector',
            u'SimpleBlobDetector::create()',
            []]],
    u'bool']
ok: FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=CALIB_CB_SYMMETRIC_GRID, ARG Ptr_FeatureDetector blobDetector=SimpleBlobDetector::create()]>

--- Incoming ---
[   u'cv.calibrateCamera',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.calibrationMatrixValues',
    u'void',
    [],
    [   ['Mat', u'cameraMatrix', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'double', u'apertureWidth', u'', []],
        [u'double', u'apertureHeight', u'', []],
        [u'double', u'fovx', u'', ['/O']],
        [u'double', u'fovy', u'', ['/O']],
        [u'double', u'focalLength', u'', ['/O']],
        [u'Point2d', u'principalPoint', u'', ['/O']],
        [u'double', u'aspectRatio', u'', ['/O']]],
    u'void']
ok: FUNC <void cv..calibrationMatrixValues [ARG Mat cameraMatrix=, ARG Size imageSize=, ARG double apertureWidth=, ARG double apertureHeight=, ARG double fovx=, ARG double fovy=, ARG double focalLength=, ARG Point2d principalPoint=, ARG double aspectRatio=]>

--- Incoming ---
[   u'cv.stereoCalibrate',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints1', '', []],
        ['vector_Mat', u'imagePoints2', '', []],
        ['Mat', u'cameraMatrix1', '', ['/IO']],
        ['Mat', u'distCoeffs1', '', ['/IO']],
        ['Mat', u'cameraMatrix2', '', ['/IO']],
        ['Mat', u'distCoeffs2', '', ['/IO']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R', '', ['/O']],
        ['Mat', u'T', '', ['/O']],
        ['Mat', u'E', '', ['/O']],
        ['Mat', u'F', '', ['/O']],
        [u'int', u'flags', u'CALIB_FIX_INTRINSIC', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)',
            []]],
    u'double']
ok: FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>

--- Incoming ---
[   u'cv.stereoRectify',
    u'void',
    [],
    [   ['Mat', u'cameraMatrix1', '', []],
        ['Mat', u'distCoeffs1', '', []],
        ['Mat', u'cameraMatrix2', '', []],
        ['Mat', u'distCoeffs2', '', []],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R', '', []],
        ['Mat', u'T', '', []],
        ['Mat', u'R1', '', ['/O']],
        ['Mat', u'R2', '', ['/O']],
        ['Mat', u'P1', '', ['/O']],
        ['Mat', u'P2', '', ['/O']],
        ['Mat', u'Q', '', ['/O']],
        [u'int', u'flags', u'CALIB_ZERO_DISPARITY', []],
        [u'double', u'alpha', u'-1', []],
        [u'Size', u'newImageSize', u'Size()', []],
        [u'Rect*', u'validPixROI1', u'0', ['/O']],
        [u'Rect*', u'validPixROI2', u'0', ['/O']]],
    u'void']
ok: FUNC <void cv..stereoRectify [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=CALIB_ZERO_DISPARITY, ARG double alpha=-1, ARG Size newImageSize=Size(), ARG Rect * validPixROI1=0, ARG Rect * validPixROI2=0]>

--- Incoming ---
[   u'cv.stereoRectifyUncalibrated',
    u'bool',
    [],
    [   ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'F', '', []],
        [u'Size', u'imgSize', u'', []],
        ['Mat', u'H1', '', ['/O']],
        ['Mat', u'H2', '', ['/O']],
        [u'double', u'threshold', u'5', []]],
    u'bool']
ok: FUNC <bool cv..stereoRectifyUncalibrated [ARG Mat points1=, ARG Mat points2=, ARG Mat F=, ARG Size imgSize=, ARG Mat H1=, ARG Mat H2=, ARG double threshold=5]>

--- Incoming ---
[   u'cv.rectify3Collinear',
    u'float',
    [],
    [   ['Mat', u'cameraMatrix1', '', []],
        ['Mat', u'distCoeffs1', '', []],
        ['Mat', u'cameraMatrix2', '', []],
        ['Mat', u'distCoeffs2', '', []],
        ['Mat', u'cameraMatrix3', '', []],
        ['Mat', u'distCoeffs3', '', []],
        ['vector_Mat', u'imgpt1', '', []],
        ['vector_Mat', u'imgpt3', '', []],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R12', '', []],
        ['Mat', u'T12', '', []],
        ['Mat', u'R13', '', []],
        ['Mat', u'T13', '', []],
        ['Mat', u'R1', '', ['/O']],
        ['Mat', u'R2', '', ['/O']],
        ['Mat', u'R3', '', ['/O']],
        ['Mat', u'P1', '', ['/O']],
        ['Mat', u'P2', '', ['/O']],
        ['Mat', u'P3', '', ['/O']],
        ['Mat', u'Q', '', ['/O']],
        [u'double', u'alpha', u'', []],
        [u'Size', u'newImgSize', u'', []],
        [u'Rect*', u'roi1', u'', ['/O']],
        [u'Rect*', u'roi2', u'', ['/O']],
        [u'int', u'flags', u'', []]],
    u'float']
ok: FUNC <float cv..rectify3Collinear [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Mat cameraMatrix3=, ARG Mat distCoeffs3=, ARG vector_Mat imgpt1=, ARG vector_Mat imgpt3=, ARG Size imageSize=, ARG Mat R12=, ARG Mat T12=, ARG Mat R13=, ARG Mat T13=, ARG Mat R1=, ARG Mat R2=, ARG Mat R3=, ARG Mat P1=, ARG Mat P2=, ARG Mat P3=, ARG Mat Q=, ARG double alpha=, ARG Size newImgSize=, ARG Rect * roi1=, ARG Rect * roi2=, ARG int flags=]>

--- Incoming ---
[   u'cv.getOptimalNewCameraMatrix',
    u'Mat',
    [],
    [   ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'double', u'alpha', u'', []],
        [u'Size', u'newImgSize', u'Size()', []],
        [u'Rect*', u'validPixROI', u'0', ['/O']],
        [u'bool', u'centerPrincipalPoint', u'false', []]],
    u'Mat']
ok: FUNC <Mat cv..getOptimalNewCameraMatrix [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Size imageSize=, ARG double alpha=, ARG Size newImgSize=Size(), ARG Rect * validPixROI=0, ARG bool centerPrincipalPoint=false]>

--- Incoming ---
[   u'cv.convertPointsToHomogeneous',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..convertPointsToHomogeneous [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.convertPointsFromHomogeneous',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..convertPointsFromHomogeneous [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.findFundamentalMat',
    u'Mat',
    [],
    [   ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        [u'int', u'method', u'FM_RANSAC', []],
        [u'double', u'param1', u'3.', []],
        [u'double', u'param2', u'0.99', []],
        ['Mat', u'mask', u'Mat()', ['/O']]],
    u'Mat']
ok: FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=FM_RANSAC, ARG double param1=3., ARG double param2=0.99, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.findEssentialMat',
    u'Mat',
    [],
    [   ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        [u'double', u'focal', u'1.0', []],
        [u'Point2d', u'pp', u'Point2d(0, 0)', []],
        [u'int', u'method', u'RANSAC', []],
        [u'double', u'prob', u'0.999', []],
        [u'double', u'threshold', u'1.0', []],
        ['Mat', u'mask', u'Mat()', ['/O']]],
    u'Mat']
ok: FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.decomposeEssentialMat',
    u'void',
    [],
    [   ['Mat', u'E', '', []],
        ['Mat', u'R1', '', ['/O']],
        ['Mat', u'R2', '', ['/O']],
        ['Mat', u't', '', ['/O']]],
    u'void']
ok: FUNC <void cv..decomposeEssentialMat [ARG Mat E=, ARG Mat R1=, ARG Mat R2=, ARG Mat t=]>

--- Incoming ---
[   u'cv.recoverPose',
    u'int',
    [],
    [   ['Mat', u'E', '', []],
        ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'R', '', ['/O']],
        ['Mat', u't', '', ['/O']],
        [u'double', u'focal', u'1.0', []],
        [u'Point2d', u'pp', u'Point2d(0, 0)', []],
        ['Mat', u'mask', u'Mat()', ['/IO']]],
    u'int']
ok: FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat R=, ARG Mat t=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.computeCorrespondEpilines',
    u'void',
    [],
    [   ['Mat', u'points', '', []],
        [u'int', u'whichImage', u'', []],
        ['Mat', u'F', '', []],
        ['Mat', u'lines', '', ['/O']]],
    u'void']
ok: FUNC <void cv..computeCorrespondEpilines [ARG Mat points=, ARG int whichImage=, ARG Mat F=, ARG Mat lines=]>

--- Incoming ---
[   u'cv.triangulatePoints',
    u'void',
    [],
    [   ['Mat', u'projMatr1', '', []],
        ['Mat', u'projMatr2', '', []],
        ['Mat', u'projPoints1', '', []],
        ['Mat', u'projPoints2', '', []],
        ['Mat', u'points4D', '', ['/O']]],
    u'void']
ok: FUNC <void cv..triangulatePoints [ARG Mat projMatr1=, ARG Mat projMatr2=, ARG Mat projPoints1=, ARG Mat projPoints2=, ARG Mat points4D=]>

--- Incoming ---
[   u'cv.correctMatches',
    u'void',
    [],
    [   ['Mat', u'F', '', []],
        ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'newPoints1', '', ['/O']],
        ['Mat', u'newPoints2', '', ['/O']]],
    u'void']
ok: FUNC <void cv..correctMatches [ARG Mat F=, ARG Mat points1=, ARG Mat points2=, ARG Mat newPoints1=, ARG Mat newPoints2=]>

--- Incoming ---
[   u'cv.filterSpeckles',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'double', u'newVal', u'', []],
        [u'int', u'maxSpeckleSize', u'', []],
        [u'double', u'maxDiff', u'', []],
        ['Mat', u'buf', u'Mat()', ['/IO']]],
    u'void']
ok: FUNC <void cv..filterSpeckles [ARG Mat img=, ARG double newVal=, ARG int maxSpeckleSize=, ARG double maxDiff=, ARG Mat buf=Mat()]>

--- Incoming ---
[   u'cv.getValidDisparityROI',
    u'Rect',
    [],
    [   [u'Rect', u'roi1', u'', []],
        [u'Rect', u'roi2', u'', []],
        [u'int', u'minDisparity', u'', []],
        [u'int', u'numberOfDisparities', u'', []],
        [u'int', u'SADWindowSize', u'', []]],
    u'Rect']
ok: FUNC <Rect cv..getValidDisparityROI [ARG Rect roi1=, ARG Rect roi2=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int SADWindowSize=]>

--- Incoming ---
[   u'cv.validateDisparity',
    u'void',
    [],
    [   ['Mat', u'disparity', '', ['/IO']],
        ['Mat', u'cost', '', []],
        [u'int', u'minDisparity', u'', []],
        [u'int', u'numberOfDisparities', u'', []],
        [u'int', u'disp12MaxDisp', u'1', []]],
    u'void']
ok: FUNC <void cv..validateDisparity [ARG Mat disparity=, ARG Mat cost=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int disp12MaxDisp=1]>

--- Incoming ---
[   u'cv.reprojectImageTo3D',
    u'void',
    [],
    [   ['Mat', u'disparity', '', []],
        ['Mat', u'_3dImage', '', ['/O']],
        ['Mat', u'Q', '', []],
        [u'bool', u'handleMissingValues', u'false', []],
        [u'int', u'ddepth', u'-1', []]],
    u'void']
ok: FUNC <void cv..reprojectImageTo3D [ARG Mat disparity=, ARG Mat _3dImage=, ARG Mat Q=, ARG bool handleMissingValues=false, ARG int ddepth=-1]>

--- Incoming ---
[   u'cv.estimateAffine3D',
    u'int',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', []],
        ['Mat', u'out', '', ['/O']],
        ['Mat', u'inliers', '', ['/O']],
        [u'double', u'ransacThreshold', u'3', []],
        [u'double', u'confidence', u'0.99', []]],
    u'int']
ok: FUNC <int cv..estimateAffine3D [ARG Mat src=, ARG Mat dst=, ARG Mat out=, ARG Mat inliers=, ARG double ransacThreshold=3, ARG double confidence=0.99]>

--- Incoming ---
[   u'cv.decomposeHomographyMat',
    u'int',
    [],
    [   ['Mat', u'H', '', []],
        ['Mat', u'K', '', []],
        ['vector_Mat', u'rotations', '', ['/O']],
        ['vector_Mat', u'translations', '', ['/O']],
        ['vector_Mat', u'normals', '', ['/O']]],
    u'int']
ok: FUNC <int cv..decomposeHomographyMat [ARG Mat H=, ARG Mat K=, ARG vector_Mat rotations=, ARG vector_Mat translations=, ARG vector_Mat normals=]>

--- Incoming ---
[u'class cv.StereoMatcher', ': cv::Algorithm', [], []]
ok: CLASS cv..StereoMatcher : Algorithm

--- Incoming ---
[u'const cv.StereoMatcher.DISP_SHIFT', u'4', [], []]
ok: CONST DISP_SHIFT=4

--- Incoming ---
[u'const cv.StereoMatcher.DISP_SCALE', u'(1 << DISP_SHIFT)', [], []]
ok: CONST DISP_SCALE=(1 << DISP_SHIFT)

--- Incoming ---
[   u'cv.StereoMatcher.compute',
    u'void',
    [],
    [   ['Mat', u'left', '', []],
        ['Mat', u'right', '', []],
        ['Mat', u'disparity', '', ['/O']]],
    u'void']
ok: FUNC <void cv.StereoMatcher.compute [ARG Mat left=, ARG Mat right=, ARG Mat disparity=]>

--- Incoming ---
[u'cv.StereoMatcher.getMinDisparity', u'int', [], [], u'int']
ok: FUNC <int cv.StereoMatcher.getMinDisparity []>

--- Incoming ---
[   u'cv.StereoMatcher.setMinDisparity',
    u'void',
    [],
    [[u'int', u'minDisparity', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setMinDisparity [ARG int minDisparity=]>

--- Incoming ---
[u'cv.StereoMatcher.getNumDisparities', u'int', [], [], u'int']
ok: FUNC <int cv.StereoMatcher.getNumDisparities []>

--- Incoming ---
[   u'cv.StereoMatcher.setNumDisparities',
    u'void',
    [],
    [[u'int', u'numDisparities', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setNumDisparities [ARG int numDisparities=]>

--- Incoming ---
[u'cv.StereoMatcher.getBlockSize', u'int', [], [], u'int']
ok: FUNC <int cv.StereoMatcher.getBlockSize []>

--- Incoming ---
[   u'cv.StereoMatcher.setBlockSize',
    u'void',
    [],
    [[u'int', u'blockSize', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setBlockSize [ARG int blockSize=]>

--- Incoming ---
[u'cv.StereoMatcher.getSpeckleWindowSize', u'int', [], [], u'int']
ok: FUNC <int cv.StereoMatcher.getSpeckleWindowSize []>

--- Incoming ---
[   u'cv.StereoMatcher.setSpeckleWindowSize',
    u'void',
    [],
    [[u'int', u'speckleWindowSize', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setSpeckleWindowSize [ARG int speckleWindowSize=]>

--- Incoming ---
[u'cv.StereoMatcher.getSpeckleRange', u'int', [], [], u'int']
ok: FUNC <int cv.StereoMatcher.getSpeckleRange []>

--- Incoming ---
[   u'cv.StereoMatcher.setSpeckleRange',
    u'void',
    [],
    [[u'int', u'speckleRange', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setSpeckleRange [ARG int speckleRange=]>

--- Incoming ---
[u'cv.StereoMatcher.getDisp12MaxDiff', u'int', [], [], u'int']
ok: FUNC <int cv.StereoMatcher.getDisp12MaxDiff []>

--- Incoming ---
[   u'cv.StereoMatcher.setDisp12MaxDiff',
    u'void',
    [],
    [[u'int', u'disp12MaxDiff', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setDisp12MaxDiff [ARG int disp12MaxDiff=]>

--- Incoming ---
[u'class cv.StereoBM', u': cv::StereoMatcher', [], []]
ok: CLASS cv..StereoBM : StereoMatcher

--- Incoming ---
[u'const cv.StereoBM.PREFILTER_NORMALIZED_RESPONSE', u'0', [], []]
ok: CONST PREFILTER_NORMALIZED_RESPONSE=0

--- Incoming ---
[u'const cv.StereoBM.PREFILTER_XSOBEL', u'1', [], []]
ok: CONST PREFILTER_XSOBEL=1

--- Incoming ---
[u'cv.StereoBM.getPreFilterType', u'int', [], [], u'int']
ok: FUNC <int cv.StereoBM.getPreFilterType []>

--- Incoming ---
[   u'cv.StereoBM.setPreFilterType',
    u'void',
    [],
    [[u'int', u'preFilterType', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setPreFilterType [ARG int preFilterType=]>

--- Incoming ---
[u'cv.StereoBM.getPreFilterSize', u'int', [], [], u'int']
ok: FUNC <int cv.StereoBM.getPreFilterSize []>

--- Incoming ---
[   u'cv.StereoBM.setPreFilterSize',
    u'void',
    [],
    [[u'int', u'preFilterSize', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setPreFilterSize [ARG int preFilterSize=]>

--- Incoming ---
[u'cv.StereoBM.getPreFilterCap', u'int', [], [], u'int']
ok: FUNC <int cv.StereoBM.getPreFilterCap []>

--- Incoming ---
[   u'cv.StereoBM.setPreFilterCap',
    u'void',
    [],
    [[u'int', u'preFilterCap', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setPreFilterCap [ARG int preFilterCap=]>

--- Incoming ---
[u'cv.StereoBM.getTextureThreshold', u'int', [], [], u'int']
ok: FUNC <int cv.StereoBM.getTextureThreshold []>

--- Incoming ---
[   u'cv.StereoBM.setTextureThreshold',
    u'void',
    [],
    [[u'int', u'textureThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setTextureThreshold [ARG int textureThreshold=]>

--- Incoming ---
[u'cv.StereoBM.getUniquenessRatio', u'int', [], [], u'int']
ok: FUNC <int cv.StereoBM.getUniquenessRatio []>

--- Incoming ---
[   u'cv.StereoBM.setUniquenessRatio',
    u'void',
    [],
    [[u'int', u'uniquenessRatio', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setUniquenessRatio [ARG int uniquenessRatio=]>

--- Incoming ---
[u'cv.StereoBM.getSmallerBlockSize', u'int', [], [], u'int']
ok: FUNC <int cv.StereoBM.getSmallerBlockSize []>

--- Incoming ---
[   u'cv.StereoBM.setSmallerBlockSize',
    u'void',
    [],
    [[u'int', u'blockSize', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setSmallerBlockSize [ARG int blockSize=]>

--- Incoming ---
[u'cv.StereoBM.getROI1', u'Rect', [], [], u'Rect']
ok: FUNC <Rect cv.StereoBM.getROI1 []>

--- Incoming ---
[u'cv.StereoBM.setROI1', u'void', [], [[u'Rect', u'roi1', u'', []]], u'void']
ok: FUNC <void cv.StereoBM.setROI1 [ARG Rect roi1=]>

--- Incoming ---
[u'cv.StereoBM.getROI2', u'Rect', [], [], u'Rect']
ok: FUNC <Rect cv.StereoBM.getROI2 []>

--- Incoming ---
[u'cv.StereoBM.setROI2', u'void', [], [[u'Rect', u'roi2', u'', []]], u'void']
ok: FUNC <void cv.StereoBM.setROI2 [ARG Rect roi2=]>

--- Incoming ---
[   u'cv.StereoBM.create',
    u'Ptr_StereoBM',
    ['/S'],
    [[u'int', u'numDisparities', u'0', []], [u'int', u'blockSize', u'21', []]],
    u'Ptr<StereoBM>']
ok: FUNC <Ptr_StereoBM cv.StereoBM.create [ARG int numDisparities=0, ARG int blockSize=21]>

--- Incoming ---
[u'class cv.StereoSGBM', u': cv::StereoMatcher', [], []]
ok: CLASS cv..StereoSGBM : StereoMatcher

--- Incoming ---
[u'const cv.StereoSGBM.MODE_SGBM', u'0', [], []]
ok: CONST MODE_SGBM=0

--- Incoming ---
[u'const cv.StereoSGBM.MODE_HH', u'1', [], []]
ok: CONST MODE_HH=1

--- Incoming ---
[u'cv.StereoSGBM.getPreFilterCap', u'int', [], [], u'int']
ok: FUNC <int cv.StereoSGBM.getPreFilterCap []>

--- Incoming ---
[   u'cv.StereoSGBM.setPreFilterCap',
    u'void',
    [],
    [[u'int', u'preFilterCap', u'', []]],
    u'void']
ok: FUNC <void cv.StereoSGBM.setPreFilterCap [ARG int preFilterCap=]>

--- Incoming ---
[u'cv.StereoSGBM.getUniquenessRatio', u'int', [], [], u'int']
ok: FUNC <int cv.StereoSGBM.getUniquenessRatio []>

--- Incoming ---
[   u'cv.StereoSGBM.setUniquenessRatio',
    u'void',
    [],
    [[u'int', u'uniquenessRatio', u'', []]],
    u'void']
ok: FUNC <void cv.StereoSGBM.setUniquenessRatio [ARG int uniquenessRatio=]>

--- Incoming ---
[u'cv.StereoSGBM.getP1', u'int', [], [], u'int']
ok: FUNC <int cv.StereoSGBM.getP1 []>

--- Incoming ---
[u'cv.StereoSGBM.setP1', u'void', [], [[u'int', u'P1', u'', []]], u'void']
ok: FUNC <void cv.StereoSGBM.setP1 [ARG int P1=]>

--- Incoming ---
[u'cv.StereoSGBM.getP2', u'int', [], [], u'int']
ok: FUNC <int cv.StereoSGBM.getP2 []>

--- Incoming ---
[u'cv.StereoSGBM.setP2', u'void', [], [[u'int', u'P2', u'', []]], u'void']
ok: FUNC <void cv.StereoSGBM.setP2 [ARG int P2=]>

--- Incoming ---
[u'cv.StereoSGBM.getMode', u'int', [], [], u'int']
ok: FUNC <int cv.StereoSGBM.getMode []>

--- Incoming ---
[u'cv.StereoSGBM.setMode', u'void', [], [[u'int', u'mode', u'', []]], u'void']
ok: FUNC <void cv.StereoSGBM.setMode [ARG int mode=]>

--- Incoming ---
[   u'cv.StereoSGBM.create',
    u'Ptr_StereoSGBM',
    ['/S'],
    [   [u'int', u'minDisparity', u'', []],
        [u'int', u'numDisparities', u'', []],
        [u'int', u'blockSize', u'', []],
        [u'int', u'P1', u'0', []],
        [u'int', u'P2', u'0', []],
        [u'int', u'disp12MaxDiff', u'0', []],
        [u'int', u'preFilterCap', u'0', []],
        [u'int', u'uniquenessRatio', u'0', []],
        [u'int', u'speckleWindowSize', u'0', []],
        [u'int', u'speckleRange', u'0', []],
        [u'int', u'mode', u'StereoSGBM::MODE_SGBM', []]],
    u'Ptr<StereoSGBM>']
ok: FUNC <Ptr_StereoSGBM cv.StereoSGBM.create [ARG int minDisparity=, ARG int numDisparities=, ARG int blockSize=, ARG int P1=0, ARG int P2=0, ARG int disp12MaxDiff=0, ARG int preFilterCap=0, ARG int uniquenessRatio=0, ARG int speckleWindowSize=0, ARG int speckleRange=0, ARG int mode=StereoSGBM::MODE_SGBM]>

--- Incoming ---
[u'const cv.fisheye.CALIB_USE_INTRINSIC_GUESS', u'1', [], []]
manual: CONST CALIB_USE_INTRINSIC_GUESS=1

--- Incoming ---
[u'const cv.fisheye.CALIB_RECOMPUTE_EXTRINSIC', u'2', [], []]
manual: CONST CALIB_RECOMPUTE_EXTRINSIC=2

--- Incoming ---
[u'const cv.fisheye.CALIB_CHECK_COND', u'4', [], []]
manual: CONST CALIB_CHECK_COND=4

--- Incoming ---
[u'const cv.fisheye.CALIB_FIX_SKEW', u'8', [], []]
manual: CONST CALIB_FIX_SKEW=8

--- Incoming ---
[u'const cv.fisheye.CALIB_FIX_K1', u'16', [], []]
manual: CONST CALIB_FIX_K1=16

--- Incoming ---
[u'const cv.fisheye.CALIB_FIX_K2', u'32', [], []]
manual: CONST CALIB_FIX_K2=32

--- Incoming ---
[u'const cv.fisheye.CALIB_FIX_K3', u'64', [], []]
manual: CONST CALIB_FIX_K3=64

--- Incoming ---
[u'const cv.fisheye.CALIB_FIX_K4', u'128', [], []]
manual: CONST CALIB_FIX_K4=128

--- Incoming ---
[u'const cv.fisheye.CALIB_FIX_INTRINSIC', u'256', [], []]
manual: CONST CALIB_FIX_INTRINSIC=256

--- Incoming ---
[   u'cv.fisheye.projectPoints',
    u'void',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', ['/O']],
        ['Mat', u'rvec', '', []],
        ['Mat', u'tvec', '', []],
        ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        [u'double', u'alpha', u'0', []],
        ['Mat', u'jacobian', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.fisheye..projectPoints [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat K=, ARG Mat D=, ARG double alpha=0, ARG Mat jacobian=Mat()]>

--- Incoming ---
[   u'cv.fisheye.distortPoints',
    u'void',
    [],
    [   ['Mat', u'undistorted', '', []],
        ['Mat', u'distorted', '', ['/O']],
        ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        [u'double', u'alpha', u'0', []]],
    u'void']
ok: FUNC <void cv.fisheye..distortPoints [ARG Mat undistorted=, ARG Mat distorted=, ARG Mat K=, ARG Mat D=, ARG double alpha=0]>

--- Incoming ---
[   u'cv.fisheye.undistortPoints',
    u'void',
    [],
    [   ['Mat', u'distorted', '', []],
        ['Mat', u'undistorted', '', ['/O']],
        ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        ['Mat', u'R', u'Mat()', []],
        ['Mat', u'P', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.fisheye..undistortPoints [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat R=Mat(), ARG Mat P=Mat()]>

--- Incoming ---
[   u'cv.fisheye.initUndistortRectifyMap',
    u'void',
    [],
    [   ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        ['Mat', u'R', '', []],
        ['Mat', u'P', '', []],
        [u'Size', u'size', u'', []],
        [u'int', u'm1type', u'', []],
        ['Mat', u'map1', '', ['/O']],
        ['Mat', u'map2', '', ['/O']]],
    u'void']
ok: FUNC <void cv.fisheye..initUndistortRectifyMap [ARG Mat K=, ARG Mat D=, ARG Mat R=, ARG Mat P=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>

--- Incoming ---
[   u'cv.fisheye.undistortImage',
    u'void',
    [],
    [   ['Mat', u'distorted', '', []],
        ['Mat', u'undistorted', '', ['/O']],
        ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        ['Mat', u'Knew', u'cv::Mat()', []],
        [u'Size', u'new_size', u'Size()', []]],
    u'void']
ok: FUNC <void cv.fisheye..undistortImage [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat Knew=cv::Mat(), ARG Size new_size=Size()]>

--- Incoming ---
[   u'cv.fisheye.estimateNewCameraMatrixForUndistortRectify',
    u'void',
    [],
    [   ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        [u'Size', u'image_size', u'', []],
        ['Mat', u'R', '', []],
        ['Mat', u'P', '', ['/O']],
        [u'double', u'balance', u'0.0', []],
        [u'Size', u'new_size', u'Size()', []],
        [u'double', u'fov_scale', u'1.0', []]],
    u'void']
ok: FUNC <void cv.fisheye..estimateNewCameraMatrixForUndistortRectify [ARG Mat K=, ARG Mat D=, ARG Size image_size=, ARG Mat R=, ARG Mat P=, ARG double balance=0.0, ARG Size new_size=Size(), ARG double fov_scale=1.0]>

--- Incoming ---
[   u'cv.fisheye.calibrate',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'image_size', u'', []],
        ['Mat', u'K', '', ['/IO']],
        ['Mat', u'D', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv.fisheye..calibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size image_size=, ARG Mat K=, ARG Mat D=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.fisheye.stereoRectify',
    u'void',
    [],
    [   ['Mat', u'K1', '', []],
        ['Mat', u'D1', '', []],
        ['Mat', u'K2', '', []],
        ['Mat', u'D2', '', []],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R', '', []],
        ['Mat', u'tvec', '', []],
        ['Mat', u'R1', '', ['/O']],
        ['Mat', u'R2', '', ['/O']],
        ['Mat', u'P1', '', ['/O']],
        ['Mat', u'P2', '', ['/O']],
        ['Mat', u'Q', '', ['/O']],
        [u'int', u'flags', u'', []],
        [u'Size', u'newImageSize', u'Size()', []],
        [u'double', u'balance', u'0.0', []],
        [u'double', u'fov_scale', u'1.0', []]],
    u'void']
ok: FUNC <void cv.fisheye..stereoRectify [ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat tvec=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=, ARG Size newImageSize=Size(), ARG double balance=0.0, ARG double fov_scale=1.0]>

--- Incoming ---
[   u'cv.fisheye.stereoCalibrate',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints1', '', []],
        ['vector_Mat', u'imagePoints2', '', []],
        ['Mat', u'K1', '', ['/IO']],
        ['Mat', u'D1', '', ['/IO']],
        ['Mat', u'K2', '', ['/IO']],
        ['Mat', u'D2', '', ['/IO']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R', '', ['/O']],
        ['Mat', u'T', '', ['/O']],
        [u'int', u'flags', u'fisheye::CALIB_FIX_INTRINSIC', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv.fisheye..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG int flags=fisheye::CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>


===== Header: /home/aydinkim/clab/opencv-3.0.0-android/modules/calib3d/include/opencv2/calib3d/calib3d.hpp =====
Namespaces: set(['', u'cv.fisheye', u'cv'])


===== Generating... =====
CLASS cv..StereoSGBM : StereoMatcher
[CONST MODE_SGBM=0, CONST MODE_HH=1]
FUNC <int cv.StereoSGBM.getPreFilterCap []>
FUNC <void cv.StereoSGBM.setPreFilterCap [ARG int preFilterCap=]>
FUNC <int cv.StereoSGBM.getUniquenessRatio []>
FUNC <void cv.StereoSGBM.setUniquenessRatio [ARG int uniquenessRatio=]>
FUNC <int cv.StereoSGBM.getP1 []>
FUNC <void cv.StereoSGBM.setP1 [ARG int P1=]>
FUNC <int cv.StereoSGBM.getP2 []>
FUNC <void cv.StereoSGBM.setP2 [ARG int P2=]>
FUNC <int cv.StereoSGBM.getMode []>
FUNC <void cv.StereoSGBM.setMode [ARG int mode=]>
FUNC <Ptr_StereoSGBM cv.StereoSGBM.create [ARG int minDisparity=, ARG int numDisparities=, ARG int blockSize=, ARG int P1=0, ARG int P2=0, ARG int disp12MaxDiff=0, ARG int preFilterCap=0, ARG int uniquenessRatio=0, ARG int speckleWindowSize=0, ARG int speckleRange=0, ARG int mode=StereoSGBM::MODE_SGBM]>
CLASS cv..StereoBM : StereoMatcher
[CONST PREFILTER_NORMALIZED_RESPONSE=0, CONST PREFILTER_XSOBEL=1]
FUNC <int cv.StereoBM.getPreFilterType []>
FUNC <void cv.StereoBM.setPreFilterType [ARG int preFilterType=]>
FUNC <int cv.StereoBM.getPreFilterSize []>
FUNC <void cv.StereoBM.setPreFilterSize [ARG int preFilterSize=]>
FUNC <int cv.StereoBM.getPreFilterCap []>
FUNC <void cv.StereoBM.setPreFilterCap [ARG int preFilterCap=]>
FUNC <int cv.StereoBM.getTextureThreshold []>
FUNC <void cv.StereoBM.setTextureThreshold [ARG int textureThreshold=]>
FUNC <int cv.StereoBM.getUniquenessRatio []>
FUNC <void cv.StereoBM.setUniquenessRatio [ARG int uniquenessRatio=]>
FUNC <int cv.StereoBM.getSmallerBlockSize []>
FUNC <void cv.StereoBM.setSmallerBlockSize [ARG int blockSize=]>
FUNC <Rect cv.StereoBM.getROI1 []>
FUNC <void cv.StereoBM.setROI1 [ARG Rect roi1=]>
FUNC <Rect cv.StereoBM.getROI2 []>
FUNC <void cv.StereoBM.setROI2 [ARG Rect roi2=]>
FUNC <Ptr_StereoBM cv.StereoBM.create [ARG int numDisparities=0, ARG int blockSize=21]>
CLASS cv..StereoMatcher : Algorithm
[CONST DISP_SHIFT=4, CONST DISP_SCALE=(1 << DISP_SHIFT)]
FUNC <int cv.StereoMatcher.getDisp12MaxDiff []>
FUNC <void cv.StereoMatcher.setDisp12MaxDiff [ARG int disp12MaxDiff=]>
FUNC <void cv.StereoMatcher.compute [ARG Mat left=, ARG Mat right=, ARG Mat disparity=]>
FUNC <int cv.StereoMatcher.getMinDisparity []>
FUNC <void cv.StereoMatcher.setMinDisparity [ARG int minDisparity=]>
FUNC <int cv.StereoMatcher.getNumDisparities []>
FUNC <void cv.StereoMatcher.setNumDisparities [ARG int numDisparities=]>
FUNC <int cv.StereoMatcher.getBlockSize []>
FUNC <void cv.StereoMatcher.setBlockSize [ARG int blockSize=]>
FUNC <int cv.StereoMatcher.getSpeckleWindowSize []>
FUNC <void cv.StereoMatcher.setSpeckleWindowSize [ARG int speckleWindowSize=]>
FUNC <int cv.StereoMatcher.getSpeckleRange []>
FUNC <void cv.StereoMatcher.setSpeckleRange [ARG int speckleRange=]>
CLASS ..Calib3d : 
[CONST CALIB_USE_INTRINSIC_GUESS=1(manual), CONST CALIB_RECOMPUTE_EXTRINSIC=2(manual), CONST CALIB_CHECK_COND=4(manual), CONST CALIB_FIX_SKEW=8(manual), CONST CALIB_FIX_K1=16(manual), CONST CALIB_FIX_K2=32(manual), CONST CALIB_FIX_K3=64(manual), CONST CALIB_FIX_K4=128(manual), CONST CALIB_FIX_INTRINSIC=256(manual), CONST CV_ITERATIVE=0, CONST CV_EPNP=1, CONST CV_P3P=2, CONST CV_DLS=3, CONST LMEDS=4, CONST RANSAC=8, CONST RHO=16, CONST SOLVEPNP_ITERATIVE=0, CONST SOLVEPNP_EPNP=1, CONST SOLVEPNP_P3P=2, CONST SOLVEPNP_DLS=3, CONST SOLVEPNP_UPNP=4, CONST CALIB_CB_ADAPTIVE_THRESH=1, CONST CALIB_CB_NORMALIZE_IMAGE=2, CONST CALIB_CB_FILTER_QUADS=4, CONST CALIB_CB_FAST_CHECK=8, CONST CALIB_CB_SYMMETRIC_GRID=1, CONST CALIB_CB_ASYMMETRIC_GRID=2, CONST CALIB_CB_CLUSTERING=4, CONST CALIB_FIX_ASPECT_RATIO=0x00002, CONST CALIB_FIX_PRINCIPAL_POINT=0x00004, CONST CALIB_ZERO_TANGENT_DIST=0x00008, CONST CALIB_FIX_FOCAL_LENGTH=0x00010, CONST CALIB_FIX_K5=0x01000, CONST CALIB_FIX_K6=0x02000, CONST CALIB_RATIONAL_MODEL=0x04000, CONST CALIB_THIN_PRISM_MODEL=0x08000, CONST CALIB_FIX_S1_S2_S3_S4=0x10000, CONST CALIB_SAME_FOCAL_LENGTH=0x00200, CONST CALIB_ZERO_DISPARITY=0x00400, CONST FM_7POINT=1, CONST FM_8POINT=2, CONST FM_LMEDS=4, CONST FM_RANSAC=8]
FUNC <void cv.fisheye..projectPoints [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat K=, ARG Mat D=, ARG double alpha=0, ARG Mat jacobian=Mat()]>
FUNC <void cv.fisheye..distortPoints [ARG Mat undistorted=, ARG Mat distorted=, ARG Mat K=, ARG Mat D=, ARG double alpha=0]>
FUNC <void cv.fisheye..undistortPoints [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat R=Mat(), ARG Mat P=Mat()]>
FUNC <void cv.fisheye..initUndistortRectifyMap [ARG Mat K=, ARG Mat D=, ARG Mat R=, ARG Mat P=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>
FUNC <void cv.fisheye..undistortImage [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat Knew=cv::Mat(), ARG Size new_size=Size()]>
FUNC <void cv.fisheye..estimateNewCameraMatrixForUndistortRectify [ARG Mat K=, ARG Mat D=, ARG Size image_size=, ARG Mat R=, ARG Mat P=, ARG double balance=0.0, ARG Size new_size=Size(), ARG double fov_scale=1.0]>
FUNC <double cv.fisheye..calibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size image_size=, ARG Mat K=, ARG Mat D=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>
FUNC <void cv.fisheye..stereoRectify [ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat tvec=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=, ARG Size newImageSize=Size(), ARG double balance=0.0, ARG double fov_scale=1.0]>
FUNC <double cv.fisheye..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG int flags=fisheye::CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>
FUNC <void cv..Rodrigues [ARG Mat src=, ARG Mat dst=, ARG Mat jacobian=Mat()]>
FUNC <Mat cv..findHomography [ARG vector_Point2f srcPoints=, ARG vector_Point2f dstPoints=, ARG int method=0, ARG double ransacReprojThreshold=3, ARG Mat mask=Mat(), ARG int maxIters=2000, ARG double confidence=0.995]>
FUNC <Vec3d cv..RQDecomp3x3 [ARG Mat src=, ARG Mat mtxR=, ARG Mat mtxQ=, ARG Mat Qx=Mat(), ARG Mat Qy=Mat(), ARG Mat Qz=Mat()]>
FUNC <void cv..decomposeProjectionMatrix [ARG Mat projMatrix=, ARG Mat cameraMatrix=, ARG Mat rotMatrix=, ARG Mat transVect=, ARG Mat rotMatrixX=Mat(), ARG Mat rotMatrixY=Mat(), ARG Mat rotMatrixZ=Mat(), ARG Mat eulerAngles=Mat()]>
FUNC <void cv..matMulDeriv [ARG Mat A=, ARG Mat B=, ARG Mat dABdA=, ARG Mat dABdB=]>
FUNC <void cv..composeRT [ARG Mat rvec1=, ARG Mat tvec1=, ARG Mat rvec2=, ARG Mat tvec2=, ARG Mat rvec3=, ARG Mat tvec3=, ARG Mat dr3dr1=Mat(), ARG Mat dr3dt1=Mat(), ARG Mat dr3dr2=Mat(), ARG Mat dr3dt2=Mat(), ARG Mat dt3dr1=Mat(), ARG Mat dt3dt1=Mat(), ARG Mat dt3dr2=Mat(), ARG Mat dt3dt2=Mat()]>
FUNC <void cv..projectPoints [ARG vector_Point3f objectPoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG vector_Point2f imagePoints=, ARG Mat jacobian=Mat(), ARG double aspectRatio=0]>
FUNC <bool cv..solvePnP [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int flags=SOLVEPNP_ITERATIVE]>
FUNC <bool cv..solvePnPRansac [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int iterationsCount=100, ARG float reprojectionError=8.0, ARG double confidence=0.99, ARG Mat inliers=Mat(), ARG int flags=SOLVEPNP_ITERATIVE]>
FUNC <Mat cv..initCameraMatrix2D [ARG vector_vector_Point3f objectPoints=, ARG vector_vector_Point2f imagePoints=, ARG Size imageSize=, ARG double aspectRatio=1.0]>
FUNC <bool cv..findChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE]>
FUNC <void cv..drawChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG bool patternWasFound=]>
FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=CALIB_CB_SYMMETRIC_GRID, ARG Ptr_FeatureDetector blobDetector=SimpleBlobDetector::create()]>
FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
FUNC <void cv..calibrationMatrixValues [ARG Mat cameraMatrix=, ARG Size imageSize=, ARG double apertureWidth=, ARG double apertureHeight=, ARG double fovx=, ARG double fovy=, ARG double focalLength=, ARG Point2d principalPoint=, ARG double aspectRatio=]>
FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>
FUNC <void cv..stereoRectify [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=CALIB_ZERO_DISPARITY, ARG double alpha=-1, ARG Size newImageSize=Size(), ARG Rect * validPixROI1=0, ARG Rect * validPixROI2=0]>
FUNC <bool cv..stereoRectifyUncalibrated [ARG Mat points1=, ARG Mat points2=, ARG Mat F=, ARG Size imgSize=, ARG Mat H1=, ARG Mat H2=, ARG double threshold=5]>
FUNC <float cv..rectify3Collinear [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Mat cameraMatrix3=, ARG Mat distCoeffs3=, ARG vector_Mat imgpt1=, ARG vector_Mat imgpt3=, ARG Size imageSize=, ARG Mat R12=, ARG Mat T12=, ARG Mat R13=, ARG Mat T13=, ARG Mat R1=, ARG Mat R2=, ARG Mat R3=, ARG Mat P1=, ARG Mat P2=, ARG Mat P3=, ARG Mat Q=, ARG double alpha=, ARG Size newImgSize=, ARG Rect * roi1=, ARG Rect * roi2=, ARG int flags=]>
FUNC <Mat cv..getOptimalNewCameraMatrix [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Size imageSize=, ARG double alpha=, ARG Size newImgSize=Size(), ARG Rect * validPixROI=0, ARG bool centerPrincipalPoint=false]>
FUNC <void cv..convertPointsToHomogeneous [ARG Mat src=, ARG Mat dst=]>
FUNC <void cv..convertPointsFromHomogeneous [ARG Mat src=, ARG Mat dst=]>
FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=FM_RANSAC, ARG double param1=3., ARG double param2=0.99, ARG Mat mask=Mat()]>
FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>
FUNC <void cv..decomposeEssentialMat [ARG Mat E=, ARG Mat R1=, ARG Mat R2=, ARG Mat t=]>
FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat R=, ARG Mat t=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG Mat mask=Mat()]>
FUNC <void cv..computeCorrespondEpilines [ARG Mat points=, ARG int whichImage=, ARG Mat F=, ARG Mat lines=]>
FUNC <void cv..triangulatePoints [ARG Mat projMatr1=, ARG Mat projMatr2=, ARG Mat projPoints1=, ARG Mat projPoints2=, ARG Mat points4D=]>
FUNC <void cv..correctMatches [ARG Mat F=, ARG Mat points1=, ARG Mat points2=, ARG Mat newPoints1=, ARG Mat newPoints2=]>
FUNC <void cv..filterSpeckles [ARG Mat img=, ARG double newVal=, ARG int maxSpeckleSize=, ARG double maxDiff=, ARG Mat buf=Mat()]>
FUNC <Rect cv..getValidDisparityROI [ARG Rect roi1=, ARG Rect roi2=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int SADWindowSize=]>
FUNC <void cv..validateDisparity [ARG Mat disparity=, ARG Mat cost=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int disp12MaxDisp=1]>
FUNC <void cv..reprojectImageTo3D [ARG Mat disparity=, ARG Mat _3dImage=, ARG Mat Q=, ARG bool handleMissingValues=false, ARG int ddepth=-1]>
FUNC <int cv..estimateAffine3D [ARG Mat src=, ARG Mat dst=, ARG Mat out=, ARG Mat inliers=, ARG double ransacThreshold=3, ARG double confidence=0.99]>
FUNC <int cv..decomposeHomographyMat [ARG Mat H=, ARG Mat K=, ARG vector_Mat rotations=, ARG vector_Mat translations=, ARG vector_Mat normals=]>
