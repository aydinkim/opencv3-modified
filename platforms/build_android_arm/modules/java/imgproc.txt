PORTED FUNCs LIST (133 of 135):

 void detect(Mat _image, Mat& _lines, Mat& width = Mat(), Mat& prec = Mat(), Mat& nfa = Mat())
 void drawSegments(Mat& _image, Mat lines)
 int compareSegments(Size size, Mat lines1, Mat lines2, Mat& _image = Mat())
  Subdiv2D()
  Subdiv2D(Rect rect)
 void initDelaunay(Rect rect)
 int insert(Point2f pt)
 void insert(vector_Point2f ptvec)
 int locate(Point2f pt, int& edge, int& vertex)
 int findNearest(Point2f pt, Point2f* nearestPt = 0)
 void getEdgeList(vector_Vec4f& edgeList)
 void getTriangleList(vector_Vec6f& triangleList)
 void getVoronoiFacetList(vector_int idx, vector_vector_Point2f& facetList, vector_Point2f& facetCenters)
 Point2f getVertex(int vertex, int* firstEdge = 0)
 int getEdge(int edge, int nextEdgeType)
 int nextEdge(int edge)
 int rotateEdge(int edge, int rotate)
 int symEdge(int edge)
 int edgeOrg(int edge, Point2f* orgpt = 0)
 int edgeDst(int edge, Point2f* dstpt = 0)
 Ptr_LineSegmentDetector createLineSegmentDetector(int _refine = LSD_REFINE_STD, double _scale = 0.8, double _sigma_scale = 0.6, double _quant = 2.0, double _ang_th = 22.5, double _log_eps = 0, double _density_th = 0.7, int _n_bins = 1024)
 Mat getGaussianKernel(int ksize, double sigma, int ktype = CV_64F)
 void getDerivKernels(Mat& kx, Mat& ky, int dx, int dy, int ksize, bool normalize = false, int ktype = CV_32F)
 Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma, double psi = CV_PI*0.5, int ktype = CV_64F)
 Mat getStructuringElement(int shape, Size ksize, Point anchor = Point(-1,-1))
 void medianBlur(Mat src, Mat& dst, int ksize)
 void GaussianBlur(Mat src, Mat& dst, Size ksize, double sigmaX, double sigmaY = 0, int borderType = BORDER_DEFAULT)
 void bilateralFilter(Mat src, Mat& dst, int d, double sigmaColor, double sigmaSpace, int borderType = BORDER_DEFAULT)
 void logPolar(Mat src, Mat& dst, Point2f center, double M, int flags)
 void linearPolar(Mat src, Mat& dst, Point2f center, double maxRadius, int flags)
 void integral(Mat src, Mat& sum, int sdepth = -1)
 void integral(Mat src, Mat& sum, Mat& sqsum, int sdepth = -1, int sqdepth = -1)
 void integral(Mat src, Mat& sum, Mat& sqsum, Mat& tilted, int sdepth = -1, int sqdepth = -1)
 void accumulate(Mat src, Mat& dst, Mat mask = Mat())
 void accumulateSquare(Mat src, Mat& dst, Mat mask = Mat())
 void accumulateProduct(Mat src1, Mat src2, Mat& dst, Mat mask = Mat())
 void accumulateWeighted(Mat src, Mat& dst, double alpha, Mat mask = Mat())
 void boxFilter(Mat src, Mat& dst, int ddepth, Size ksize, Point anchor = Point(-1,-1), bool normalize = true, int borderType = BORDER_DEFAULT)
 void sqrBoxFilter(Mat _src, Mat& _dst, int ddepth, Size ksize, Point anchor = Point(-1, -1), bool normalize = true, int borderType = BORDER_DEFAULT)
 void blur(Mat src, Mat& dst, Size ksize, Point anchor = Point(-1,-1), int borderType = BORDER_DEFAULT)
 void filter2D(Mat src, Mat& dst, int ddepth, Mat kernel, Point anchor = Point(-1,-1), double delta = 0, int borderType = BORDER_DEFAULT)
 void sepFilter2D(Mat src, Mat& dst, int ddepth, Mat kernelX, Mat kernelY, Point anchor = Point(-1,-1), double delta = 0, int borderType = BORDER_DEFAULT)
 void Sobel(Mat src, Mat& dst, int ddepth, int dx, int dy, int ksize = 3, double scale = 1, double delta = 0, int borderType = BORDER_DEFAULT)
 void Scharr(Mat src, Mat& dst, int ddepth, int dx, int dy, double scale = 1, double delta = 0, int borderType = BORDER_DEFAULT)
 void Laplacian(Mat src, Mat& dst, int ddepth, int ksize = 1, double scale = 1, double delta = 0, int borderType = BORDER_DEFAULT)
 void Canny(Mat image, Mat& edges, double threshold1, double threshold2, int apertureSize = 3, bool L2gradient = false)
 void cornerMinEigenVal(Mat src, Mat& dst, int blockSize, int ksize = 3, int borderType = BORDER_DEFAULT)
 void cornerHarris(Mat src, Mat& dst, int blockSize, int ksize, double k, int borderType = BORDER_DEFAULT)
 void cornerEigenValsAndVecs(Mat src, Mat& dst, int blockSize, int ksize, int borderType = BORDER_DEFAULT)
 void preCornerDetect(Mat src, Mat& dst, int ksize, int borderType = BORDER_DEFAULT)
 void cornerSubPix(Mat image, vector_Point2f& corners, Size winSize, Size zeroZone, TermCriteria criteria)
 void goodFeaturesToTrack(Mat image, vector_Point& corners, int maxCorners, double qualityLevel, double minDistance, Mat mask = Mat(), int blockSize = 3, bool useHarrisDetector = false, double k = 0.04)
 void HoughLines(Mat image, Mat& lines, double rho, double theta, int threshold, double srn = 0, double stn = 0, double min_theta = 0, double max_theta = CV_PI)
 void HoughLinesP(Mat image, Mat& lines, double rho, double theta, int threshold, double minLineLength = 0, double maxLineGap = 0)
 void HoughCircles(Mat image, Mat& circles, int method, double dp, double minDist, double param1 = 100, double param2 = 100, int minRadius = 0, int maxRadius = 0)
 void erode(Mat src, Mat& dst, Mat kernel, Point anchor = Point(-1,-1), int iterations = 1, int borderType = BORDER_CONSTANT, Scalar borderValue = morphologyDefaultBorderValue())
 void dilate(Mat src, Mat& dst, Mat kernel, Point anchor = Point(-1,-1), int iterations = 1, int borderType = BORDER_CONSTANT, Scalar borderValue = morphologyDefaultBorderValue())
 void morphologyEx(Mat src, Mat& dst, int op, Mat kernel, Point anchor = Point(-1,-1), int iterations = 1, int borderType = BORDER_CONSTANT, Scalar borderValue = morphologyDefaultBorderValue())
 void resize(Mat src, Mat& dst, Size dsize, double fx = 0, double fy = 0, int interpolation = INTER_LINEAR)
 void warpAffine(Mat src, Mat& dst, Mat M, Size dsize, int flags = INTER_LINEAR, int borderMode = BORDER_CONSTANT, Scalar borderValue = Scalar())
 void warpPerspective(Mat src, Mat& dst, Mat M, Size dsize, int flags = INTER_LINEAR, int borderMode = BORDER_CONSTANT, Scalar borderValue = Scalar())
 void remap(Mat src, Mat& dst, Mat map1, Mat map2, int interpolation, int borderMode = BORDER_CONSTANT, Scalar borderValue = Scalar())
 void convertMaps(Mat map1, Mat map2, Mat& dstmap1, Mat& dstmap2, int dstmap1type, bool nninterpolation = false)
 Mat getRotationMatrix2D(Point2f center, double angle, double scale)
 void invertAffineTransform(Mat M, Mat& iM)
 Mat getPerspectiveTransform(Mat src, Mat dst)
 Mat getAffineTransform(vector_Point2f src, vector_Point2f dst)
 void getRectSubPix(Mat image, Size patchSize, Point2f center, Mat& patch, int patchType = -1)
 Point2d phaseCorrelate(Mat src1, Mat src2, Mat window = Mat(), double* response = 0)
 void createHanningWindow(Mat& dst, Size winSize, int type)
 double threshold(Mat src, Mat& dst, double thresh, double maxval, int type)
 void adaptiveThreshold(Mat src, Mat& dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)
 void pyrDown(Mat src, Mat& dst, Size dstsize = Size(), int borderType = BORDER_DEFAULT)
 void pyrUp(Mat src, Mat& dst, Size dstsize = Size(), int borderType = BORDER_DEFAULT)
 void undistort(Mat src, Mat& dst, Mat cameraMatrix, Mat distCoeffs, Mat newCameraMatrix = Mat())
 void initUndistortRectifyMap(Mat cameraMatrix, Mat distCoeffs, Mat R, Mat newCameraMatrix, Size size, int m1type, Mat& map1, Mat& map2)
 float initWideAngleProjMap(Mat cameraMatrix, Mat distCoeffs, Size imageSize, int destImageWidth, int m1type, Mat& map1, Mat& map2, int projType = PROJ_SPHERICAL_EQRECT, double alpha = 0)
 Mat getDefaultNewCameraMatrix(Mat cameraMatrix, Size imgsize = Size(), bool centerPrincipalPoint = false)
 void undistortPoints(vector_Point2f src, vector_Point2f& dst, Mat cameraMatrix, Mat distCoeffs, Mat R = Mat(), Mat P = Mat())
 void calcHist(vector_Mat images, vector_int channels, Mat mask, Mat& hist, vector_int histSize, vector_float ranges, bool accumulate = false)
 void calcBackProject(vector_Mat images, vector_int channels, Mat hist, Mat& dst, vector_float ranges, double scale)
 double compareHist(Mat H1, Mat H2, int method)
 void equalizeHist(Mat src, Mat& dst)
 void watershed(Mat image, Mat& markers)
 void pyrMeanShiftFiltering(Mat src, Mat& dst, double sp, double sr, int maxLevel = 1, TermCriteria termcrit = TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1))
 void grabCut(Mat img, Mat& mask, Rect rect, Mat& bgdModel, Mat& fgdModel, int iterCount, int mode = GC_EVAL)
 void distanceTransform(Mat src, Mat& dst, Mat& labels, int distanceType, int maskSize, int labelType = DIST_LABEL_CCOMP)
 void distanceTransform(Mat src, Mat& dst, int distanceType, int maskSize, int dstType = CV_32F)
 int floodFill(Mat& image, Mat& mask, Point seedPoint, Scalar newVal, Rect* rect = 0, Scalar loDiff = Scalar(), Scalar upDiff = Scalar(), int flags = 4)
 void cvtColor(Mat src, Mat& dst, int code, int dstCn = 0)
 void demosaicing(Mat _src, Mat& _dst, int code, int dcn = 0)
 void matchTemplate(Mat image, Mat templ, Mat& result, int method, Mat mask = Mat())
 int connectedComponents(Mat image, Mat& labels, int connectivity = 8, int ltype = CV_32S)
 int connectedComponentsWithStats(Mat image, Mat& labels, Mat& stats, Mat& centroids, int connectivity = 8, int ltype = CV_32S)
 void findContours(Mat& image, vector_vector_Point& contours, Mat& hierarchy, int mode, int method, Point offset = Point())
 void approxPolyDP(vector_Point2f curve, vector_Point2f& approxCurve, double epsilon, bool closed)
 double arcLength(vector_Point2f curve, bool closed)
 Rect boundingRect(vector_Point points)
 double contourArea(Mat contour, bool oriented = false)
 RotatedRect minAreaRect(vector_Point2f points)
 void boxPoints(RotatedRect box, Mat& points)
 void minEnclosingCircle(vector_Point2f points, Point2f& center, float& radius)
 double minEnclosingTriangle(Mat points, Mat& triangle)
 double matchShapes(Mat contour1, Mat contour2, int method, double parameter)
 void convexHull(vector_Point points, vector_int& hull, bool clockwise = false,  _hidden_  returnPoints = true)
 void convexityDefects(vector_Point contour, vector_int convexhull, vector_Vec4i& convexityDefects)
 bool isContourConvex(vector_Point contour)
 float intersectConvexConvex(Mat _p1, Mat _p2, Mat& _p12, bool handleNested = true)
 RotatedRect fitEllipse(vector_Point2f points)
 void fitLine(Mat points, Mat& line, int distType, double param, double reps, double aeps)
 double pointPolygonTest(vector_Point2f contour, Point2f pt, bool measureDist)
 int rotatedRectangleIntersection(RotatedRect rect1, RotatedRect rect2, Mat& intersectingRegion)
 Ptr_CLAHE createCLAHE(double clipLimit = 40.0, Size tileGridSize = Size(8, 8))
 void applyColorMap(Mat src, Mat& dst, int colormap)
 void line(Mat& img, Point pt1, Point pt2, Scalar color, int thickness = 1, int lineType = LINE_8, int shift = 0)
 void arrowedLine(Mat& img, Point pt1, Point pt2, Scalar color, int thickness = 1, int line_type = 8, int shift = 0, double tipLength = 0.1)
 void rectangle(Mat& img, Point pt1, Point pt2, Scalar color, int thickness = 1, int lineType = LINE_8, int shift = 0)
 void circle(Mat& img, Point center, int radius, Scalar color, int thickness = 1, int lineType = LINE_8, int shift = 0)
 void ellipse(Mat& img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color, int thickness = 1, int lineType = LINE_8, int shift = 0)
 void ellipse(Mat& img, RotatedRect box, Scalar color, int thickness = 1, int lineType = LINE_8)
 void fillConvexPoly(Mat& img, vector_Point points, Scalar color, int lineType = LINE_8, int shift = 0)
 void fillPoly(Mat& img, vector_vector_Point pts, Scalar color, int lineType = LINE_8, int shift = 0, Point offset = Point())
 void polylines(Mat& img, vector_vector_Point pts, bool isClosed, Scalar color, int thickness = 1, int lineType = LINE_8, int shift = 0)
 void drawContours(Mat& image, vector_vector_Point contours, int contourIdx, Scalar color, int thickness = 1, int lineType = LINE_8, Mat hierarchy = Mat(), int maxLevel = INT_MAX, Point offset = Point())
 bool clipLine(Rect imgRect, Point& pt1, Point& pt2)
 void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, vector_Point& pts)
 void putText(Mat& img, String text, Point org, int fontFace, double fontScale, Scalar color, int thickness = 1, int lineType = LINE_8, bool bottomLeftOrigin = false)
 void apply(Mat src, Mat& dst)
 void setClipLimit(double clipLimit)
 double getClipLimit()
 void setTilesGridSize(Size tileGridSize)
 Size getTilesGridSize()
 void collectGarbage()

SKIPPED FUNCs LIST (2 of 135):

 Moments moments(Mat array, bool binaryImage = false)
// Return type 'Moments' is not supported, skipping the function

 void HuMoments(Moments m, Mat& hu)
// Unknown type 'Moments' (I), skipping the function


0 def args - 54 funcs
1 def args - 30 funcs
2 def args - 23 funcs
3 def args - 16 funcs
4 def args - 10 funcs
5 def args - 1 funcs
8 def args - 1 funcs